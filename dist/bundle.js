/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return App; });\nclass App {\n  constructor() {\n    this.uiData = {\n      settings: {\n        visible: false,\n      }\n    };\n  }\n\n  showSettings() {\n    this.uiData.settings.visible = true;\n  }\n\n  hideSettings() {\n    this.uiData.settings.visible = false;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n}\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/audio.js":
/*!*************************!*\
  !*** ./src/js/audio.js ***!
  \*************************/
/*! exports provided: Audio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\nconst BEEP = 'beep';\n// Duration of beep in seconds.\nconst BEEP_DURATION = 0.05;\n\nclass Audio {\n  constructor() {\n    /** @type {!AudioContext} */\n    this.audioContext = new AudioContext();\n    /** @type {boolean} Whether audio context has been unlocked. */\n    this.unlocked = false;\n\n    this.sampleUrlsMap = {\n      'hihat': 'static/sounds/hihat.wav'\n    };\n\n    // Map name to buffer.\n    this.buffers = {};\n\n    this.uiData = {\n      sampleName: BEEP,\n    }\n  }\n\n  // Play silent buffer to unlock the audio.\n  unlockAudio() {\n    console.log('[audio.js] unlock audio');\n    if (!this.unlocked) {\n      var buffer = this.audioContext.createBuffer(1, 1, 22050);\n      var node = this.audioContext.createBufferSource();\n      node.buffer = buffer;\n      node.start(0);\n      this.unlocked = true;\n    }\n  }\n\n  getAudioContext() {\n    return this.audioContext;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  /**\n   * Schedule the sound at startTime. beatNumber from 0 to 15 (16th notes).\n   */\n  scheduleSound(beatNumber, noteTime) {\n    // console.log('[audio.js] scheduleSound()');\n    if (this.uiData.sampleName == BEEP) {\n      let freq;\n      if (beatNumber % 16 === 0) {  // beat 0 = high pitch\n        freq = 880.0;\n      } else if (beatNumber % 4 === 0) {  // quarter notes = medium pitch\n        freq = 440.0;\n      } else {  // other 16th notes = low pitch\n        freq = 220.0;\n      }\n      let osc = this.audioContext.createOscillator();\n      osc.connect(this.audioContext.destination);\n      osc.frequency.value = freq;\n      osc.start(noteTime);\n      osc.stop(noteTime + BEEP_DURATION);\n    } else {\n      if (!(this.uiData.sampleName in this.buffers)) {\n        console.warn(\n            '[audio.js] sample not in sample map: ' + this.uiData.sampleName);\n        return;\n      }\n      let node = this.audioContext.createBufferSource();\n      node.buffer = this.buffers[this.uiData.sampleName];\n      node.connect(this.audioContext.destination);\n      node.start(noteTime);\n    }\n  }\n\n  maybeLoadSample() {\n    if (this.uiData.sampleName == BEEP) {\n      return;\n    }\n    // Only load new sample if it hasn't been loaded before.\n    if (!(this.uiData.sampleName in this.buffers)) {\n      console.log('[audio.js] Loading sample for ' + this.uiData.sampleName);\n      new BufferLoader(this.audioContext, [this.uiData.sampleName], this.sampleUrlsMap, (buffers) => {\n        Object.keys(buffers).forEach((key, index) => {\n          // Insert the fetched buffer along with existing buffers, so we don't\n          // re-load.\n          this.buffers[key] = buffers[key];\n        });\n      }).load();\n    }\n  }\n\n  loadSamples() {\n  }\n}\n\nclass BufferLoader {\n  constructor(context, sampleNames, sampleUrlsMap, callback) {\n    this.context = context;\n    this.sampleNames = sampleNames;\n    this.sampleUrlsMap = sampleUrlsMap;\n    this.onload = callback;\n    this.buffers = {};\n    this.loadCount = 0;\n  }\n\n  load() {\n    for (var i = 0; i < this.sampleNames.length; ++i) {\n      this.loadBuffer(this.sampleNames[i]);\n    }\n  }\n\n  loadBuffer(sampleName) {\n    let url = this.sampleUrlsMap[sampleName];\n    // Load buffer asynchronously\n    let request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n\n    let loader = this;\n\n    request.onload = function() {\n      // Asynchronously decode the audio file data in request.response\n      loader.context.decodeAudioData(\n        request.response,\n        function(buffer) {\n          if (!buffer) {\n            alert('error decoding file data: ' + url);\n            return;\n          }\n          loader.buffers[sampleName] = buffer;\n          if (++loader.loadCount == loader.sampleNames.length)\n            loader.onload(loader.buffers);\n        },\n        function(error) {\n          console.error('decodeAudioData error', error);\n        }\n      );\n    }\n\n    request.onerror = function() {\n      alert('BufferLoader: XHR error');\n    }\n\n    request.send();\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/js/audio.js?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio.js */ \"./src/js/audio.js\");\n/* harmony import */ var _metronome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metronome.js */ \"./src/js/metronome.js\");\n/* harmony import */ var _visualization_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visualization.js */ \"./src/js/visualization.js\");\n/* harmony import */ var _songchart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./songchart.js */ \"./src/js/songchart.js\");\n/* harmony import */ var _app_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app.js */ \"./src/js/app.js\");\n\n\n\n\n\n\nwindow.init = function() {\n  // First, let's shim the requestAnimationFrame API, with a setTimeout fallback\n  window.requestAnimFrame = (function() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\n        window.msRequestAnimationFrame || function(callback) {\n          window.setTimeout(callback, 1000 / 60);\n        };\n  })();\n\n  let songChart = new _songchart_js__WEBPACK_IMPORTED_MODULE_3__[\"SongChart\"]();\n\n  let audio = new _audio_js__WEBPACK_IMPORTED_MODULE_0__[\"Audio\"]();\n  audio.loadSamples();\n\n  let viz = new _visualization_js__WEBPACK_IMPORTED_MODULE_2__[\"Viz\"](window, document, audio);\n  viz.initCanvas();\n\n  let metronome = new _metronome_js__WEBPACK_IMPORTED_MODULE_1__[\"Metronome\"](audio, viz);\n  metronome.setSongChart(songChart);\n\n  let app = new _app_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n\n  let vueApp = new Vue({\n    el: '#vueApp',\n    data: {\n      audio: audio.getUiData(),\n      metronome: metronome.getUiData(),\n      songChart: songChart.getUiData(),\n      app: app.getUiData(),\n    },\n    methods: {\n      metronomeToggle: (() => { metronome.toggle(); }),\n      metronomeStop: (() => { metronome.stop(); }),\n      metronomeTapTempo: (() => { metronome.tapTempo(); }),\n      metronomeTempoHalve: (() => { metronome.tempoHalve(); }),\n      metronomeTempoDecrementBy10: (() => { metronome.tempoDecrementBy10(); }),\n      metronomeTempoDecrementBy5: (() => { metronome.tempoDecrementBy5(); }),\n      metronomeTempoDecrement: (() => { metronome.tempoDecrement(); }),\n      metronomeTempoIncrement: (() => { metronome.tempoIncrement(); }),\n      metronomeTempoIncrementBy5: (() => { metronome.tempoIncrementBy5(); }),\n      metronomeTempoIncrementBy10: (() => { metronome.tempoIncrementBy10(); }),\n      metronomeTempoDouble: (() => { metronome.tempoDouble(); }),\n\n      songChartSetStartingFromSection: ((index) => { songChart.setStartingFromSection(index); }),\n      songChartAppendSection: (() => { songChart.appendSection(); }),\n      songChartToggle: (() => { songChart.toggle(); }),\n\n      appShowSettings: (() => { app.showSettings(); }),\n      appHideSettings: (() => { app.hideSettings(); }),\n\n      audioMaybeLoadSample: (() => { audio.maybeLoadSample(); })\n    }\n  });\n\n}\n\nwindow.addEventListener('load', window.init);\n\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ }),

/***/ "./src/js/metronome.js":
/*!*****************************!*\
  !*** ./src/js/metronome.js ***!
  \*****************************/
/*! exports provided: Metronome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Metronome\", function() { return Metronome; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\n/** @const {number} */\nconst QUARTER_NOTE = 0;\n/** @const {number} */\nconst EIGHTH_NOTE = 1;\n/** @const {number} */\nconst SIXTEENTH_NOTE = 2;\n\n/** Metronome class for handling scheduling and current beat. */\nclass Metronome {\n  constructor(audio, viz) {\n    /** @type {!audio.Audio} */\n    this.audio = audio;\n    this.audioContext = this.audio.getAudioContext();\n\n    this.viz = viz;\n\n    this.timerWorker = this.createTimerWorker();\n    // When the next note is due.\n    this.nextNoteTime = 0.0;\n    // How far ahead to schedule audio (sec). This is calculated from lookahead,\n    // and overlaps with next interval (in case the timer is late)\n    this.scheduleAheadTime = 0.1;\n\n    // What note is currently last scheduled?\n    this.current16thNote;\n\n    this.songChart;\n    // At the beginning the song chart already starts at the first beat. However\n    // the metronome audio has yet to schedule the first note. So don't tick the\n    // songchart on the first note.\n    this.songChartSkippedFirstNote = false;\n\n    this.uiData = {\n      isPlaying: false,\n      toggleLabel: 'START',\n      tempo: 135,\n      noteResolution: QUARTER_NOTE\n    };\n\n    // Accumulate current audioContext time for calculating tempo.\n    this.tapTempoPoints = [];\n    // Last audioContext time that the user tapped. Used to reset the points.\n    this.lastTapTime = -1;\n  }\n\n  createTimerWorker() {\n    var w = new Worker('src/js/metronomeworker.js');\n    w.onmessage = e => {\n      if (e.data == 'TICK') {\n        this.scheduler();\n      }\n    };\n    return w;\n  }\n\n  nextNote() {\n    // Advance current note and time by a 16th note...\n    // Notice this picks up the CURRENT tempo value to calculate beat length.\n    let secondsPerBeat = 60.0 / this.uiData.tempo;\n    // Add beat length to last beat time\n    this.nextNoteTime += 0.25 * secondsPerBeat;\n    // Advance the beat number, wrapping to zero\n    this.current16thNote = (this.current16thNote + 1) % 16;\n\n    if (this.songChartSkippedFirstNote && this.songChart.getUiData().enabled) {\n      if (!this.songChart.tick()) {\n        console.log('[metronome.js] Stopping at end of song.');\n        this.stop();\n      }\n    } else {\n      this.songChartSkippedFirstNote = true;\n    }\n  }\n\n  scheduleNote(beatNumber, noteTime) {\n    // Append note in queue for visualization.\n    this.viz.appendNote({note: beatNumber, time: noteTime});\n\n    if ((this.uiData.noteResolution == EIGHTH_NOTE) && (beatNumber % 2))\n      return;  // we're not playing non-8th 16th notes\n    if ((this.uiData.noteResolution == QUARTER_NOTE) && (beatNumber % 4))\n      return;  // we're not playing non-quarter 8th notes\n\n    this.audio.scheduleSound(beatNumber, noteTime);\n  }\n\n  scheduler() {\n    // while there are notes that will need to play before the next interval,\n    // schedule them and advance the pointer.\n    while (this.nextNoteTime <\n           (this.audioContext.currentTime + this.scheduleAheadTime)) {\n      this.scheduleNote(this.current16thNote, this.nextNoteTime);\n      this.nextNote();\n    }\n  }\n\n  toggle() {\n    if (!this.uiData.isPlaying) {\n      this.start();\n    } else {\n      this.stop();\n    }\n  }\n\n  /** Starts the metronome. */\n  start(delayMs = 0.5) {\n    if (!this.uiData.isPlaying) {\n      // Must resume audio context after a user gesture on the page.\n      // https://goo.gl/7K7W\n      this.audio.unlockAudio();\n      this.audioContext.resume();\n      this.current16thNote = 0;\n      this.uiData.isPlaying = true;\n      this.uiData.toggleLabel = 'STOP';\n      // Set first note to be 0.5s from now (when user clicks).\n      this.nextNoteTime = this.audioContext.currentTime + delayMs;\n      this.timerWorker.postMessage('START');\n    }\n  }\n\n  /** Stops the metronome and resets. For now assumes reset from the beginning. */\n  stop() {\n    if (this.uiData.isPlaying) {\n      this.uiData.isPlaying = false;\n      this.current16thNote = 0;\n      this.timerWorker.postMessage('STOP');\n      this.uiData.toggleLabel = 'START';\n      this.songChartSkippedFirstNote = false;\n      this.songChart.reset();\n    }\n  }\n\n  setSongChart(songChart) {\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkIsDefined\"]('songChart', songChart);\n    this.songChart = songChart;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  setTempo(tempo) {\n    this.uiData.tempo = tempo;\n  }\n\n  tapTempo() {\n    let t = this.audioContext.currentTime;\n    if (this.lastTapTime == -1 || (t - this.lastTapTime) >= 5) {\n      // Remove all taps older than 5 secs.\n      this.tapTempoPoints = [t];\n      this.lastTapTime = t;\n      // Return on first tap.\n      return;\n    }\n    this.tapTempoPoints.push(t);\n    if (this.tapTempoPoints.length <= 1) {\n      console.warn(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"sprintf\"](\n          \"[metronome.js] Tap tempo got $ points, expected at least 2.\",\n          this.tapTempoPoints.length));\n      return;\n    }\n    this.lastTapTime = t;\n    // Calculate average interval from maximum last 4 points and set tempo.\n    let sumIntervals = 0;\n    let countIntervals = 0;\n    let lastInterval = -1;\n    let i = this.tapTempoPoints.length - 1;\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n         this.tapTempoPoints.length >= 2,\n         \"Expect more than 2 tempo points, got $ points\",\n         this.tapTempoPoints.length)) {\n      return;\n    }\n    while(countIntervals <= 4 && i > 0) {\n      let interval = this.tapTempoPoints[i] - this.tapTempoPoints[i - 1];\n      if (lastInterval != -1 && (interval >= 2 * lastInterval || interval <= 0.5 * lastInterval)) {\n        // If a interval is less than half or more than twice the last interval,\n        // that indicates a change in tempo. Don't include them.\n        break;\n      }\n      sumIntervals += interval;\n      countIntervals += 1;\n      i--;\n    }\n    let avgInterval = sumIntervals / countIntervals;\n    if (avgInterval <= 0) {\n      console.warn(\"[metronome.js] Average interval = 0\");\n      return;\n    }\n    this.uiData.tempo = (60.0 / (sumIntervals / countIntervals)).toFixed(2);\n    if (this.tapTempoPoints.length >= 5 && !this.uiData.isPlaying) {\n      // Starts on the 5th tap (next measure first beat)\n      this.start(/* delayMs= */0);\n    }\n  }\n\n  tempoHalve() { this.uiData.tempo /= 2; }\n  tempoDecrementBy10() { this.uiData.tempo -= 10; }\n  tempoDecrementBy5() { this.uiData.tempo -= 5; }\n  tempoDecrement() { this.uiData.tempo -= 1; }\n  tempoIncrement() { this.uiData.tempo += 1; }\n  tempoIncrementBy5() { this.uiData.tempo += 5; }\n  tempoIncrementBy10() { this.uiData.tempo += 10; }\n  tempoDouble() { this.uiData.tempo *= 2; }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/js/metronome.js?");

/***/ }),

/***/ "./src/js/songchart.js":
/*!*****************************!*\
  !*** ./src/js/songchart.js ***!
  \*****************************/
/*! exports provided: SongChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SongChart\", function() { return SongChart; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\n// How many beats in a measure.\nconst BEATS = 4\n\nconst NUT_JSON = {\n  \"name\": \"Nứt\",\n  \"artist\": \"Ngọt\",\n  \"tempo\": \"145\",\n  \"time_signature\": \"4/4\",\n  \"sections\": [\n    {\n      \"name\": \"Intro\",\n      \"length\": 16,\n      \"subsections\": [\n        {\n          \"subname\": \"Piano\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Guitar\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 2\n        }\n      ]\n    }, {\n      \"name\": \"Solo\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 5\n        }\n      ]\n    }, {\n      \"name\": \"Verse\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 9\n        }, {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 9\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 1\n        }\n      ]\n    }, {\n      \"name\": \"Prechorus\",\n      \"length\": 8,\n      \"subsections\": [\n        {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 2\n        },\n      ]\n    }, {\n      \"name\": \"Chorus\",\n      \"length\": 16,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        },\n      ]\n    }, {\n      \"name\": \"Interlude/Solo\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 5\n        },\n      ]\n    }\n  ]\n};\n\n/** Class for handling song charting. */\nclass SongChart {\n  constructor(json) {\n    this.json = json || NUT_JSON;\n\n    this.uiData = {\n      enabled: true,\n\n      name: this.json.name,\n      artist: this.json.artist,\n\n      countIn: {\n        enabled: true,\n        lengthMeasures: 2,\n        curCountInMeasure: 1\n      },\n\n      // Current beat of the measure. 1 to BEATS (4).\n      curBeat: 1,\n      // Current measure of the section. 1 to `measures` in json.\n      curMeasure: 1,\n      // Current section name and length in measures.\n      curSectionName: '',\n      curSectionLength: 0,\n      curSectionIndex: 0,\n      sections: this.json.sections,\n      // Current subsection index, or -1 if there is no subsection.\n      curSubSectionIndex: -1,\n      curSubSectionMeasure: -1,\n\n      // Current total running measures.\n      curRunningMeasures: 1\n    };\n\n    this.startingSection = 0;\n\n    // Current tick of the beat. 0 to 3 (16th notes).\n    this.curTick = 0;\n\n    // Update uiData based on JSON data, e.g. section name and length.\n    this.reset();\n  }\n\n  reset() {\n    this.uiData.countIn.curCountInMeasure = 1;\n\n    this.curTick = 0;\n    this.uiData.curBeat = 1;\n    this.setStartingFromSection(this.startingSection);\n  }\n\n  /**\n   * Sets the current selected section to play from.\n   * @param {int} index - Selected section index.\n   * @returns The number of measures before this section, plus 1 (first measure\n   *     of this section).\n   */\n  setStartingFromSection(index) {\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n        index < this.json.sections.length,\n        'Selected index: $ while there are only $ sections',\n                      index, this.json.sections.length);\n    this.startingSection = index;\n    this.uiData.curSectionIndex = index;\n    this.uiData.curMeasure = 1;\n    let section = this.getCurrentSection();\n    this.uiData.curSectionName = section.name;\n    this.uiData.curSectionLength = section.length;\n    let subsections = this.getCurrentSubSections();\n    if (subsections.length) {\n      this.uiData.curSubSectionIndex = 0;\n      this.uiData.curSubSectionMeasure = 1;\n    } else {\n      this.uiData.curSubSectionIndex = -1;\n      this.uiData.curSubSectionMeasure = -1;\n    }\n    let s = 0;\n    for (let i = 0; i < index; i++) {\n      s += this.json.sections[i].length * BEATS;\n    }\n    this.uiData.curRunningMeasures = s + 1;  // +1 because it starts from 1.\n  }\n\n  getCurrentSection() {\n    return this.json.sections[this.uiData.curSectionIndex];\n  }\n\n  /** Returns list of subsections corresponding to the current section, or empty\n   * list if the property does not exist.\n   */\n  getCurrentSubSections() {\n    let currentSection = this.getCurrentSection();\n    if (currentSection.hasOwnProperty('subsections')) {\n      return currentSection.subsections;\n    }\n    return [];\n  }\n\n  /** Returns false if the end has been reached. */\n  tick() {\n    this.curTick += 1;\n    if (this.curTick >= 4) {\n      this.curTick = 0;\n      return this.nextBeat();\n    }\n    return true;\n  }\n\n  /** Update next beat. If it's the end of a measure, update the next measure. */\n  nextBeat() {\n    this.uiData.curBeat += 1;\n    if (this.uiData.curBeat > BEATS) {\n      this.uiData.curBeat = 1;\n      return this.nextMeasure();\n    }\n    return true;\n  }\n\n  /** Update next measure. If it's the end of a section, update the next section. */\n  nextMeasure() {\n    let countIn = this.uiData.countIn;\n    if (countIn.enabled === true\n        && countIn.curCountInMeasure <= countIn.lengthMeasures) {\n      countIn.curCountInMeasure += 1;\n      // Don't go to the next measure in this call just yet.\n      return true;\n    }\n    this.uiData.curRunningMeasures += 1;\n    this.uiData.curMeasure += 1;\n    let section = this.getCurrentSection();\n    if (this.uiData.curMeasure > section.length) {\n      this.uiData.curMeasure = 1;\n      return this.nextSection();\n    } else {\n      // Next measure of sub sections within this section.\n      this.nextSubSectionMeasure(/* newSection= */ false);\n      return true;\n    }\n  }\n\n  /**\n   * Check and increment sub section measures.\n   * @param newSection If true, this next subsection is of the next section.\n   *     If false, this next subsection is of the same section.\n   */\n  nextSubSectionMeasure(newSection) {\n    if (newSection) {\n      let section = this.getCurrentSection();\n      if (section.hasOwnProperty('subsections')) {\n        // First measure of the first subsection.\n        this.uiData.curSubSectionIndex = 0;\n        this.uiData.curSubSectionMeasure = 1;\n      } else {\n        this.uiData.curSubSectionIndex = -1;\n        this.uiData.curSubSectionMeasure = -1;\n      }\n    } else {\n      if (this.uiData.curSubSectionIndex != -1) {\n        this.uiData.curSubSectionMeasure += 1;\n        let currentSection = this.getCurrentSection();\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n            currentSection.hasOwnProperty('subsections'),\n            '[songchart.js] Current section (index: '\n            + this.uiData.curSectionIndex + ') does not have subsections, yet '\n            + 'incrementing to next subsection');\n        let currentSubSection =\n            currentSection.subsections[this.uiData.curSubSectionIndex];\n        // Measure count starts from 1.\n        if (this.uiData.curSubSectionMeasure > currentSubSection.sublength) {\n          // Next subsection.\n          this.uiData.curSubSectionIndex += 1;\n          _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n            this.uiData.curSubSectionIndex\n                < currentSection.subsections.length,\n            '[songchart.js] Incrementing to next subsection index out of '\n            + ' bound: ' + this.uiData.curSectionIndex + ', subsection index: '\n            + this.uiData.curSubSectionIndex);\n          this.uiData.curSubSectionMeasure = 1;\n        }\n      }\n    }\n  }\n\n  /** Update next section. Returns false if the end has been reached. */\n  nextSection() {\n    this.uiData.curSectionIndex += 1;\n    if (this.uiData.curSectionIndex >= this.json.sections.length) {\n      this.reset();\n      return false;\n    }\n    let section = this.getCurrentSection();\n    this.uiData.curSectionName = section.name;\n    this.uiData.curSectionLength = section.length;\n    this.nextSubSectionMeasure(/* newSection= */ true);\n    return true;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  appendSection() {\n    this.json.sections.push({\n        \"name\": \"Untitled\",\n        \"length\": 8,\n    });\n  }\n\n  toggle() {\n    this.uiData.enabled = !this.uiData.enabled;\n  }\n\n  /**\n   * Sum of sub sections lengths must match section's total length. \n   * @returns List of section indices that violate this condition, or an empty\n   *     list.\n   */\n  validateSubSectionsLength() {\n    let indices = [];\n    for (let i = 0; i < this.json.sections.length; i++) {\n      let section = this.json.sections[i];\n      let sum = 0;\n      if (!section.hasOwnProperty('subsections')) {\n        continue;\n      }\n      for (let j = 0; j < section.subsections.length; j++) {\n        sum += section.subsections[j].length;\n      }\n      if (sum != section.length) {\n        indices.push(i);\n      }\n    }\n    return indices;\n  }\n\n  // For testing only.\n  setCountInMeasures(measures) {\n    this.uiData.countIn.lengthMeasures = measures;\n  }\n\n  /**\n   * Fetches song chart from given url.\n   * @param {string} url Url.\n  async fetchFromJson(url) {\n    let response = await fetch(url);\n    let song = await response.json();\n\n    // wait 1 second\n    await new Promise((resolve, reject) => setTimeout(resolve, 1000));\n\n    return song;\n  }\n  */\n}\n\n\n\n//# sourceURL=webpack:///./src/js/songchart.js?");

/***/ }),

/***/ "./src/js/utils.js":
/*!*************************!*\
  !*** ./src/js/utils.js ***!
  \*************************/
/*! exports provided: checkState, checkIsDefined, sprintf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkState\", function() { return checkState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkIsDefined\", function() { return checkIsDefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sprintf\", function() { return sprintf; });\nvar sprintf = (str, ...argv) => !argv.length ? str : \n    sprintf(str = str.replace(sprintf.token||\"$\", argv.shift()), ...argv);\n    \nfunction checkState(cond, message, ...argv) {\n  if (!cond) {\n    console.error(\"[ERROR] INVALID STATE: \" + sprintf(message, ...argv));\n    return false;\n  }\n  return true;\n}\n\nfunction checkIsDefined(name, value) {\n  if (typeof value !== 'undefined') {\n    if (value !== null){\n      return true;\n    }\n  }\n  console.error(\"[ERROR] %s is not defined: %s\", name, value);\n  return false;\n}\n\n\n\n//# sourceURL=webpack:///./src/js/utils.js?");

/***/ }),

/***/ "./src/js/visualization.js":
/*!*********************************!*\
  !*** ./src/js/visualization.js ***!
  \*********************************/
/*! exports provided: Viz */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viz\", function() { return Viz; });\nclass Viz {\n  constructor(window, document, audio) {\n    this.audioContext = audio.getAudioContext();\n    this.window = window;\n    this.document = document;\n    this.canvas;\n    this.canvasContext;\n\n    // The last 'box' we drew on the screen\n    this.last16thNoteDrawn = -1;\n\n    // Notes that have been put into the web audio, and may or may not have\n    // played yet. {note, time}\n    this.notesInQueue = [];\n  }\n\n  /**\n   * Appends note in the queue for visualization.\n   * @param noteAndTime An object with `note` and `time` props.\n   */\n  appendNote(noteAndTime) {\n    this.notesInQueue.push(noteAndTime);\n  }\n\n  initCanvas() {\n    this.canvas = this.document.createElement('canvas');\n    this.canvasContext = this.canvas.getContext('2d');\n    this.canvas.width = this.window.innerWidth;\n    this.canvas.height = this.window.innerHeight;\n    this.canvasContext.strokeStyle = '#ffffff';\n    this.canvasContext.lineWidth = 2;\n\n    /*\n    var container = this.document.createElement('div');\n    container.className = 'container';\n    container.appendChild(this.canvas);\n\n    this.document.body.appendChild(container);\n    */\n\n    this.window.onorientationchange = () => { this.resetCanvas(); };\n    this.window.onresize = () => { this.resetCanvas(); };\n\n    // Starts the drawing loop.\n    this.window.requestAnimFrame(() => {this.draw()});\n  }\n\n  draw() {\n    var currentNote = this.last16thNoteDrawn;\n    var currentTime = this.audioContext.currentTime;\n\n    while (this.notesInQueue.length &&\n           this.notesInQueue[0].time < currentTime) {\n      currentNote = this.notesInQueue[0].note;\n      this.notesInQueue.splice(0, 1);  // remove note from queue\n    }\n\n    // We only need to draw if the note has moved.\n    if (this.last16thNoteDrawn != currentNote) {\n      var x = Math.floor(this.canvas.width / 18);\n      this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      for (var i = 0; i < 16; i++) {\n        this.canvasContext.fillStyle = (currentNote == i) ?\n            ((currentNote % 4 === 0) ? 'red' : 'blue') :\n            'black';\n        this.canvasContext.fillRect(x * (i + 1), x, x / 2, x / 2);\n      }\n      this.last16thNoteDrawn = currentNote;\n    }\n\n    // Set up to draw again\n    this.window.requestAnimFrame(() => {this.draw()});\n  }\n\n  resetCanvas() {\n    // Resize canvas. This will also clears the canvas.\n    this.canvas.width = this.window.innerWidth;\n    this.canvas.height = this.window.innerHeight;\n\n    // Scroll to the top left.\n    this.window.scrollTo(0, 0);\n  }\n}\n\n\n\n//# sourceURL=webpack:///./src/js/visualization.js?");

/***/ })

/******/ });