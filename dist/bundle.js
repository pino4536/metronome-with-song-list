/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return App; });\nclass App {\n  constructor() {\n    this.uiData = {\n      settings: {\n        visible: false,\n        flashRedOnFirstBeat: true,\n        hidePastSections: true\n      }\n    };\n  }\n\n  showSettings() {\n    this.uiData.settings.visible = true;\n  }\n\n  hideSettings() {\n    this.uiData.settings.visible = false;\n  }\n\n  popOut() {\n    window.open(\n      'index.html',\n      '_blank',\n      'width=400,height=600,resizable=no,scrollbars=no,menubar=no,location=no,status=no,toolbar=no');\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n}\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/audio.js":
/*!*************************!*\
  !*** ./src/js/audio.js ***!
  \*************************/
/*! exports provided: Audio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\nconst BEEP_LOW = 'BEEP_LOW';\nconst BEEP_HIGH = 'BEEP_HIGH';\n// Duration of beep in seconds.\nconst BEEP_DURATION = 0.05;\n\nconst GAIN_LEVEL_STORAGE_KEY = 'AUDIO_GAIN_LEVEL';\nconst GAIN_LEVEL_MAX_VALUE = 1.2;  // Must be in sync with HTML range input max.\n\nclass Audio {\n  constructor(storage) {\n    /** @type {!Storage} */\n    this.storage = storage;\n\n    /** @type {!AudioContext} */\n    this.audioContext = new AudioContext({ latencyHint: 'interactive' });\n    this.baseLatency = null;\n\n    /** @type {boolean} Whether audio context has been unlocked. */\n    this.unlocked = false;\n\n    this.sampleUrlsMap = {\n      'HIHAT': 'static/sounds/hihat.wav'\n    };\n\n    // Map name to buffer.\n    this.buffers = {};\n\n    this.uiData = {\n      sampleName: BEEP_HIGH,\n      gainNode: this.audioContext.createGain()\n    }\n\n    this.uiData.gainNode.gain.value = Math.min(\n        this.storage.get(GAIN_LEVEL_STORAGE_KEY) || 1.0,\n        GAIN_LEVEL_MAX_VALUE);\n    this.uiData.gainNode.connect(this.audioContext.destination);\n  }\n\n  // Play silent buffer to unlock the audio.\n  unlockAudio() {\n    if (!this.unlocked) {\n      var buffer = this.audioContext.createBuffer(1, 1, 22050);\n      var node = this.audioContext.createBufferSource();\n      node.buffer = buffer;\n      node.start(0);\n      this.unlocked = true;\n    }\n  }\n\n  getAudioContext() {\n    return this.audioContext;\n  }\n\n  /**\n   * Returns audioContext.baseLatency.\n   *\n   * .baseLatency is not supported in a few browsers, including Safari and\n   * Firefox-on-Android.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/baseLatency\n   */\n  getBaseLatency() {\n    if (this.baseLatency !== null) {\n      return this.baseLatency;\n    }\n    if (this.audioContext.state === 'running') {\n      this.baseLatency = this.audioContext.baseLatency || 0;\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"log\"]('AudioContext base latency: $ secs',\n          this.baseLatency.toFixed(6));\n      return this.baseLatency;\n    }\n    return 0;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  /**\n   * Schedule the sound at startTime. beatNumber from 0 to 15 (16th notes).\n   */\n  scheduleSound(beatNumber, noteTime) {\n    if (this.uiData.sampleName == BEEP_LOW\n        || this.uiData.sampleName == BEEP_HIGH) {\n      let freq;\n      if (beatNumber % 16 === 0) {  // beat 0 = high pitch\n        freq = 880.0;\n      } else if (beatNumber % 4 === 0) {  // quarter notes = medium pitch\n        freq = 440.0;\n      } else {  // other 16th notes = low pitch\n        freq = 220.0;\n      }\n      if (this.uiData.sampleName == BEEP_HIGH) {\n        freq *= 2;\n      }\n      let osc = this.audioContext.createOscillator();\n      osc.connect(this.uiData.gainNode);\n      osc.frequency.value = freq;\n      osc.start(noteTime);\n      osc.stop(noteTime + BEEP_DURATION);\n    } else {\n      if (!(this.uiData.sampleName in this.buffers)) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"warn\"]('sample not in sample map: $', this.uiData.sampleName);\n        return;\n      }\n      let node = this.audioContext.createBufferSource();\n      node.buffer = this.buffers[this.uiData.sampleName];\n      node.connect(this.uiData.gainNode);\n      node.start(noteTime);\n    }\n  }\n\n  /**\n   * In HTML we use v-model.number with a v-on:change reference to this method,\n   * so that the value can be stored in local storage.\n   */\n  updatedGainLevel() {\n    this.storage.store(\n        GAIN_LEVEL_STORAGE_KEY,\n        Math.max(this.uiData.gainNode.gain.value, GAIN_LEVEL_MAX_VALUE));\n  }\n\n  maybeLoadSample() {\n    if (this.uiData.sampleName == BEEP_LOW\n        || this.uiData.sampleName == BEEP_HIGH) {\n      return;\n    }\n    // Only load new sample if it hasn't been loaded before.\n    if (!(this.uiData.sampleName in this.buffers)) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"log\"]('Loading sample: $', this.uiData.sampleName);\n      new BufferLoader(this.audioContext, [this.uiData.sampleName], this.sampleUrlsMap, (buffers) => {\n        Object.keys(buffers).forEach((key, index) => {\n          // Insert the fetched buffer along with existing buffers, so we don't\n          // re-load.\n          this.buffers[key] = buffers[key];\n        });\n      }).load();\n    }\n  }\n}\n\nclass BufferLoader {\n  constructor(context, sampleNames, sampleUrlsMap, callback) {\n    this.context = context;\n    this.sampleNames = sampleNames;\n    this.sampleUrlsMap = sampleUrlsMap;\n    this.onload = callback;\n    this.buffers = {};\n    this.loadCount = 0;\n  }\n\n  load() {\n    for (var i = 0; i < this.sampleNames.length; ++i) {\n      this.loadBuffer(this.sampleNames[i]);\n    }\n  }\n\n  loadBuffer(sampleName) {\n    let url = this.sampleUrlsMap[sampleName];\n    // Load buffer asynchronously\n    let request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n\n    let loader = this;\n\n    request.onload = function() {\n      // Asynchronously decode the audio file data in request.response\n      loader.context.decodeAudioData(\n        request.response,\n        function(buffer) {\n          if (!buffer) {\n            alert('Failed to decode sound file :( ' + url);\n            return;\n          }\n          loader.buffers[sampleName] = buffer;\n          if (++loader.loadCount == loader.sampleNames.length)\n            loader.onload(loader.buffers);\n        },\n        function(error) {\n          console.error('Failed to decode sound file :(', error);\n        }\n      );\n    }\n    request.onerror = function() {\n      alert('Failed to load sound files :(');\n    }\n\n    request.send();\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/js/audio.js?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio.js */ \"./src/js/audio.js\");\n/* harmony import */ var _metronome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metronome.js */ \"./src/js/metronome.js\");\n/* harmony import */ var _visualization_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visualization.js */ \"./src/js/visualization.js\");\n/* harmony import */ var _songchart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./songchart.js */ \"./src/js/songchart.js\");\n/* harmony import */ var _app_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app.js */ \"./src/js/app.js\");\n/* harmony import */ var _shortcuts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shortcuts.js */ \"./src/js/shortcuts.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage.js */ \"./src/js/storage.js\");\n\n\n\n\n\n\n\n\nwindow.init = function() {\n  // First, let's shim the requestAnimationFrame API, with a setTimeout fallback\n  window.requestAnimFrame = (function() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\n        window.msRequestAnimationFrame || function(callback) {\n          window.setTimeout(callback, 1000 / 60);\n        };\n  })();\n\n  let storage = new _storage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](window);\n\n  let songChart = new _songchart_js__WEBPACK_IMPORTED_MODULE_3__[\"SongChart\"]();\n\n  let audio = new _audio_js__WEBPACK_IMPORTED_MODULE_0__[\"Audio\"](storage);\n  audio.maybeLoadSample();\n\n  let viz = new _visualization_js__WEBPACK_IMPORTED_MODULE_2__[\"Viz\"](window, document, audio);\n  viz.initCanvas();\n\n  let metronome = new _metronome_js__WEBPACK_IMPORTED_MODULE_1__[\"Metronome\"](audio, viz);\n  metronome.setSongChart(songChart);\n\n  new _shortcuts_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](window).bindMetronome(metronome);\n\n  let app = new _app_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n\n  let vueApp = new Vue({\n    el: '#vueApp',\n    data: {\n      audio: audio.getUiData(),\n      metronome: metronome.getUiData(),\n      songChart: songChart.getUiData(),\n      app: app.getUiData()\n    },\n    methods: {\n      metronomeToggle: (() => { metronome.toggle(); }),\n      metronomeStop: (() => { metronome.stop(); }),\n      metronomeTapTempo: (() => { metronome.tapTempo(); }),\n      metronomeTempoHalve: (() => { metronome.tempoHalve(); }),\n      metronomeTempoDecrementBy10: (() => { metronome.tempoDecrementBy10(); }),\n      metronomeTempoDecrementBy5: (() => { metronome.tempoDecrementBy5(); }),\n      metronomeTempoDecrement: (() => { metronome.tempoDecrement(); }),\n      metronomeTempoIncrement: (() => { metronome.tempoIncrement(); }),\n      metronomeTempoIncrementBy5: (() => { metronome.tempoIncrementBy5(); }),\n      metronomeTempoIncrementBy10: (() => { metronome.tempoIncrementBy10(); }),\n      metronomeTempoDouble: (() => { metronome.tempoDouble(); }),\n\n      songChartSetStartingFromSection: ((index) => { songChart.setStartingFromSection(index); }),\n      songChartAppendSection: (() => { songChart.appendSection(); }),\n      songChartToggle: (() => { songChart.toggle(); }),\n\n      appShowSettings: (() => { app.showSettings(); }),\n      appHideSettings: (() => { app.hideSettings(); }),\n      appPopOut: (() => { app.popOut(); }),\n\n      audioMaybeLoadSample: (() => { audio.maybeLoadSample(); }),\n      audioUpdatedGainLevel: (() => { audio.updatedGainLevel(); })\n    }\n  });\n\n}\n\nwindow.addEventListener('load', window.init);\n\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ }),

/***/ "./src/js/metronome.js":
/*!*****************************!*\
  !*** ./src/js/metronome.js ***!
  \*****************************/
/*! exports provided: Metronome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Metronome\", function() { return Metronome; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\n/** @const {number} */\nconst QUARTER_NOTE = 0;\n/** @const {number} */\nconst EIGHTH_NOTE = 1;\n/** @const {number} */\nconst SIXTEENTH_NOTE = 2;\n\n/** Metronome class for handling scheduling and current beat. */\nclass Metronome {\n  constructor(audio, viz) {\n    /** @type {!audio.Audio} */\n    this.audio = audio;\n    this.audioContext = this.audio.getAudioContext();\n\n    this.viz = viz;\n\n    this.timerWorker = this.createTimerWorker();\n    // When the next note is due.\n    this.nextNoteTime = 0.0;\n    // How far ahead to schedule audio (sec). This is calculated from lookahead,\n    // and overlaps with next interval (in case the timer is late)\n    this.scheduleAheadTime = 0.1;\n\n    // Note that was last scheduled. Do not rely on this for UI since it won't\n    // be in sync.\n    this.current16thNote;\n\n    this.songChart;\n    // When paused the song chart already starts at the first beat. However\n    // the metronome audio has yet to schedule the first beat. So don't tick the\n    // songchart on the first beat.\n    this.songChartSkippedFirstNote = false;\n\n    this.uiData = {\n      isPlaying: false,\n      toggleLabel: 'START',\n      tempo: 135,\n      noteResolution: QUARTER_NOTE\n    };\n\n    // Store note time's plus audio latency. These are used to determine *when*\n    // to make calls that propagate to Vue models, so that data models changes\n    // are sync'ed with audio and visuals.\n    // This acts as a queue, so that each note will make sure to 'tick' the song\n    // chart by one beat. In case things are delayed, the song chart will be\n    // tick'ed once for each note queued up.\n    this.audioDelayedNoteTimes = [];\n\n    // Accumulate current audioContext time for calculating tempo.\n    this.tapTempoPoints = [];\n    // Last audioContext time that the user tapped. Used to reset the points.\n    this.lastTapTime = -1;\n  }\n\n  createTimerWorker() {\n    let w = new Worker('src/js/metronomeworker.js');\n    w.onmessage = e => {\n      if (e.data == 'TICK') {\n        this.scheduler();\n      }\n    };\n    return w;\n  }\n\n  nextNote() {\n    // Advance current note and time by a 16th note...\n    // Notice this picks up the CURRENT tempo value to calculate beat length.\n    let secondsPerBeat = 60.0 / this.uiData.tempo;\n    // Add beat length to last beat time\n    this.nextNoteTime += 0.25 * secondsPerBeat;\n    // Advance the beat number, wrapping to zero\n    this.current16thNote = (this.current16thNote + 1) % 16;\n  }\n\n  scheduleNote(beatNumber, noteTime) {\n    if ((this.uiData.noteResolution == EIGHTH_NOTE) && (beatNumber % 2))\n      return;  // we're not playing non-8th 16th notes\n    if ((this.uiData.noteResolution == QUARTER_NOTE) && (beatNumber % 4))\n      return;  // we're not playing non-quarter 8th notes\n\n    // beatNumber is 0 - 15, while we only need 0 - 3 for visualization purpose.\n    if (beatNumber % 4 == 0) {\n      // Append note in queue for visualization.\n      // Some mobile browsers may have a problem with audio lagging, where\n      // baseLatency is as much as 0.09 seconds. This causes visualization to run\n      // ahead of the audible sounds.\n      // To fix this, we draw late compare to the actual note time, depending on\n      // how much the baseLatency lag is.\n      this.viz.appendNote(beatNumber, noteTime + this.audio.getBaseLatency());\n    }\n    this.audio.scheduleSound(beatNumber, noteTime);\n\n    // Don't advance the song chart here yet. Store the note time and wait until\n    // the next note time is near to update.\n    this.audioDelayedNoteTimes.push(noteTime + this.audio.getBaseLatency());\n  }\n\n  maybeTickSongChart() {\n    if (this.songChart.getUiData().enabled) {\n      let currentTime = this.audioContext.currentTime;\n      while(this.audioDelayedNoteTimes.length\n          && this.audioDelayedNoteTimes[0] <= currentTime) {\n        let noteTime = this.audioDelayedNoteTimes[0];\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"log\"](\n            '[songchart] currentTime: $, noteTime: $ ($)',\n            currentTime.toFixed(6), noteTime.toFixed(6),\n            (noteTime - currentTime).toFixed(6));\n        // Remove note.\n        this.audioDelayedNoteTimes.splice(0, 1);\n        if (!this.songChartSkippedFirstNote) {\n          this.songChartSkippedFirstNote = true;\n          return;\n        }\n        if (!this.songChart.nextBeat()) {\n          console.log('Stopping at end of song.');\n          this.stop();\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate note times and schedule notes for audio and visualization.\n   *\n   * Called once per metronome worker tick.\n   */\n  scheduler() {\n    this.maybeTickSongChart();\n\n    // When nextNoteTime (in the future) is near (gap is determined by \n    // scheduleAheadTime), schedule audio & visuals and advance to the next\n    // note.\n    while (this.nextNoteTime <\n           (this.audioContext.currentTime + this.scheduleAheadTime)) {\n      this.scheduleNote(this.current16thNote, this.nextNoteTime);\n      this.nextNote();\n    }\n  }\n\n  toggle() {\n    if (!this.uiData.isPlaying) {\n      this.start();\n    } else {\n      this.stop();\n    }\n  }\n\n  /** Starts the metronome. */\n  start(delayMs = 0.5) {\n    if (!this.uiData.isPlaying) {\n      // Must resume audio context after a user gesture on the page.\n      // https://goo.gl/7K7W\n      if (this.audioContext.state === 'suspended') {\n        this.audioContext.resume();\n      }\n      this.audio.unlockAudio();\n      this.current16thNote = 0;\n      this.uiData.isPlaying = true;\n      this.uiData.toggleLabel = 'STOP';\n      // Set first note to be 0.5s from now (when user clicks).\n      this.nextNoteTime = this.audioContext.currentTime + delayMs;\n      this.timerWorker.postMessage('START');\n      this.viz.startDrawing();\n    }\n  }\n\n  /** Stops the metronome and resets. For now assumes reset from the beginning. */\n  stop() {\n    if (this.uiData.isPlaying) {\n      this.uiData.isPlaying = false;\n      this.current16thNote = 0;\n      this.timerWorker.postMessage('STOP');\n      this.uiData.toggleLabel = 'START';\n      this.songChartSkippedFirstNote = false;\n      this.songChart.reset();\n      this.viz.stopDrawing();\n    }\n  }\n\n  setSongChart(songChart) {\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkIsDefined\"]('songChart', songChart);\n    this.songChart = songChart;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  setTempo(tempo) {\n    this.uiData.tempo = tempo;\n  }\n\n  tapTempo() {\n    // Since we create audioContext on page load, it's in suspended state.\n    // Without this resume() call, `.currentTime` maybe 0.\n    this.audioContext.resume();\n    let t = this.audioContext.currentTime;\n    if (this.lastTapTime == -1 || (t - this.lastTapTime) >= 5) {\n      // Remove all taps older than 5 secs.\n      this.tapTempoPoints = [t];\n      this.lastTapTime = t;\n      // Return on first tap.\n      return;\n    }\n    this.tapTempoPoints.push(t);\n    if (this.tapTempoPoints.length <= 1) {\n      console.warn(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"sprintf\"](\n          \"[metronome.js] Tap tempo got $ points, expected at least 2.\",\n          this.tapTempoPoints.length));\n      return;\n    }\n    this.lastTapTime = t;\n    // Calculate average interval from maximum last 4 points and set tempo.\n    let sumIntervals = 0;\n    let countIntervals = 0;\n    let prevInterval = -1;\n    let i = this.tapTempoPoints.length - 1;\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n         this.tapTempoPoints.length >= 2,\n         \"Expect more than 2 tempo points, got $ points\",\n         this.tapTempoPoints.length)) {\n      return;\n    }\n    while(countIntervals <= 4 && i > 0) {\n      let curInterval = this.tapTempoPoints[i] - this.tapTempoPoints[i - 1];\n      if (prevInterval != -1\n          && (curInterval >= 1.5 * prevInterval\n              || curInterval <= 0.66 * prevInterval)) {\n        // If the difference between the last interval (newer) vs this current\n        // interval (older) is too much, that indicates a change in tempo. Don't\n        // include the older ones.\n        break;\n      }\n      sumIntervals += curInterval;\n      countIntervals += 1;\n      i--;\n    }\n    let avgInterval = sumIntervals / countIntervals;\n    if (avgInterval <= 0) {\n      console.warn(\"[metronome.js] Average interval = 0 \"\n                   + \"(perhaps audioContext hasn't been resumed?)\");\n      return;\n    }\n    this.uiData.tempo = (60.0 / (sumIntervals / countIntervals)).toFixed(2);\n    if (this.tapTempoPoints.length == 5 && !this.uiData.isPlaying) {\n      // Starts on the 5th tap (next measure first beat)\n      this.start(/* delayMs= */0);\n    }\n  }\n\n  tempoHalve() { this.uiData.tempo /= 2; }\n  tempoDecrementBy10() { this.uiData.tempo -= 10; }\n  tempoDecrementBy5() { this.uiData.tempo -= 5; }\n  tempoDecrement() { this.uiData.tempo -= 1; }\n  tempoIncrement() { this.uiData.tempo += 1; }\n  tempoIncrementBy5() { this.uiData.tempo += 5; }\n  tempoIncrementBy10() { this.uiData.tempo += 10; }\n  tempoDouble() { this.uiData.tempo *= 2; }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/js/metronome.js?");

/***/ }),

/***/ "./src/js/shortcuts.js":
/*!*****************************!*\
  !*** ./src/js/shortcuts.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Shortcuts; });\nconst TEMPO_BOX_ID = 'tempoBox';\nconst SUBDIVISION_BOX_ID = 'subdivisionBox';\n\nclass Shortcuts {\n  constructor(window) {\n    this.window = window;\n  }\n\n  bindMetronome(metronome) {\n    this.window.Mousetrap.bindGlobal('.', function (e) {\n      e.preventDefault();\n      metronome.tapTempo();\n    });\n    this.window.Mousetrap.bindGlobal('t', function (e) {\n      e.preventDefault();\n      window.document.getElementById(TEMPO_BOX_ID).focus();\n    });\n    this.window.Mousetrap.bindGlobal('b', function (e) {\n      e.preventDefault();\n      window.document.getElementById(SUBDIVISION_BOX_ID).focus();\n    });\n    this.window.Mousetrap.bindGlobal('space', function (e) {\n      e.preventDefault();\n      metronome.toggle();\n    });\n    this.window.Mousetrap.bindGlobal('up', function () {\n      if (document.activeElement.tagName !== 'INPUT') {\n        metronome.tempoIncrement();\n      }\n    });\n    this.window.Mousetrap.bindGlobal('down', function () {\n      if (document.activeElement.tagName !== 'INPUT') {\n        metronome.tempoDecrement();\n      }\n    });\n    this.window.Mousetrap.bindGlobal('left', function () {\n      if (document.activeElement.tagName !== 'INPUT') {\n        metronome.tempoDecrementBy5();\n      }\n    });\n    this.window.Mousetrap.bindGlobal('right', function () {\n      if (document.activeElement.tagName !== 'INPUT') {\n        metronome.tempoIncrementBy5();\n      }\n    });\n    this.window.Mousetrap.bindGlobal('j', function () {\n      metronome.tempoDecrement();\n    });\n    this.window.Mousetrap.bindGlobal('k', function () {\n      metronome.tempoIncrement();\n    });\n    this.window.Mousetrap.bindGlobal('m', function () {\n      metronome.tempoDecrementBy5();\n    });\n    this.window.Mousetrap.bindGlobal(',', function () {\n      metronome.tempoIncrementBy5();\n    });\n  }\n}\n\n//# sourceURL=webpack:///./src/js/shortcuts.js?");

/***/ }),

/***/ "./src/js/songchart.js":
/*!*****************************!*\
  !*** ./src/js/songchart.js ***!
  \*****************************/
/*! exports provided: SongChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SongChart\", function() { return SongChart; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\n// How many beats in a measure.\nconst BEATS = 4\n\nconst NUT_JSON = {\n  \"name\": \"Nứt\",\n  \"artist\": \"Ngọt\",\n  \"tempo\": \"145\",\n  \"time_signature\": \"4/4\",\n  \"sections\": [\n    {\n      \"name\": \"Intro\",\n      \"length\": 16,\n      \"subsections\": [\n        {\n          \"subname\": \"Piano\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Guitar\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 2\n        }\n      ]\n    }, {\n      \"name\": \"Solo\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 5\n        }\n      ]\n    }, {\n      \"name\": \"Verse\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 9\n        }, {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 9\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 1\n        }\n      ]\n    }, {\n      \"name\": \"Prechorus\",\n      \"length\": 8,\n      \"subsections\": [\n        {\n          \"subname\": \"Verse Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 2\n        },\n      ]\n    }, {\n      \"name\": \"Chorus\",\n      \"length\": 16,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        },\n      ]\n    }, {\n      \"name\": \"Interlude/Solo\",\n      \"length\": 19,\n      \"subsections\": [\n        {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 8\n        }, {\n          \"subname\": \"Chorus Groove\",\n          \"sublength\": 6\n        }, {\n          \"subname\": \"Fill\",\n          \"sublength\": 5\n        },\n      ]\n    }\n  ]\n};\n\n/** Class for handling song charting. */\nclass SongChart {\n  constructor(json) {\n    this.json = json || NUT_JSON;\n\n    this.uiData = {\n      enabled: true,\n\n      name: this.json.name,\n      artist: this.json.artist,\n\n      countIn: {\n        enabled: true,\n        lengthMeasures: 2,\n        curCountInMeasure: 1\n      },\n\n      visualCues: {\n        enabled: true,\n        yellowLength: 1,\n        redLength: 2,\n      },\n\n      // Current beat of the measure. 1 to BEATS (4).\n      curBeat: 1,\n      // Current measure of the section. 1 to `measures` in json.\n      curMeasure: 1,\n      // Current section name and length in measures.\n      curSectionName: '',\n      curSectionLength: 0,\n      curSectionIndex: 0,\n      sections: this.json.sections,\n      // Current subsection index, or -1 if there is no subsection.\n      curSubSectionIndex: -1,\n      curSubSectionMeasure: -1,\n\n      // Current total running measures.\n      curRunningMeasures: 1\n    };\n\n    this.startingSection = 0;\n\n    // Update uiData based on JSON data, e.g. section name and length.\n    this.reset();\n  }\n\n  reset() {\n    this.uiData.countIn.curCountInMeasure = 1;\n\n    this.uiData.curBeat = 1;\n    this.setStartingFromSection(this.startingSection);\n  }\n\n  /**\n   * Sets the current selected section to play from.\n   * @param {int} index - Selected section index.\n   * @returns The number of measures before this section, plus 1 (first measure\n   *     of this section).\n   */\n  setStartingFromSection(index) {\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n        index < this.json.sections.length,\n        'Selected index: $ while there are only $ sections',\n                      index, this.json.sections.length);\n    this.startingSection = index;\n    this.uiData.curSectionIndex = index;\n    this.uiData.curMeasure = 1;\n    let section = this.getCurrentSection();\n    this.uiData.curSectionName = section.name;\n    this.uiData.curSectionLength = section.length;\n    let subsections = this.getCurrentSubSections();\n    if (subsections.length) {\n      this.uiData.curSubSectionIndex = 0;\n      this.uiData.curSubSectionMeasure = 1;\n    } else {\n      this.uiData.curSubSectionIndex = -1;\n      this.uiData.curSubSectionMeasure = -1;\n    }\n    let s = 0;\n    for (let i = 0; i < index; i++) {\n      s += this.json.sections[i].length;\n    }\n    this.uiData.curRunningMeasures = s + 1;  // +1 because it starts from 1.\n  }\n\n  getCurrentSection() {\n    return this.json.sections[this.uiData.curSectionIndex];\n  }\n\n  /** Returns list of subsections corresponding to the current section, or empty\n   * list if the property does not exist.\n   */\n  getCurrentSubSections() {\n    let currentSection = this.getCurrentSection();\n    if (currentSection.hasOwnProperty('subsections')) {\n      return currentSection.subsections;\n    }\n    return [];\n  }\n\n  /** Update next beat. If it's the end of a measure, update the next measure. */\n  nextBeat() {\n    this.uiData.curBeat += 1;\n    if (this.uiData.curBeat > BEATS) {\n      this.uiData.curBeat = 1;\n      return this.nextMeasure();\n    }\n    return true;\n  }\n\n  /** Update next measure. If it's the end of a section, update the next section. */\n  nextMeasure() {\n    let countIn = this.uiData.countIn;\n    if (countIn.enabled === true\n        && countIn.curCountInMeasure <= countIn.lengthMeasures) {\n      countIn.curCountInMeasure += 1;\n      // Don't go to the next measure in this call just yet.\n      return true;\n    }\n    this.uiData.curRunningMeasures += 1;\n    this.uiData.curMeasure += 1;\n    let section = this.getCurrentSection();\n    if (this.uiData.curMeasure > section.length) {\n      this.uiData.curMeasure = 1;\n      return this.nextSection();\n    } else {\n      // Next measure of sub sections within this section.\n      this.nextSubSectionMeasure(/* newSection= */ false);\n      return true;\n    }\n  }\n\n  /**\n   * Check and increment sub section measures.\n   * @param newSection If true, this next subsection is of the next section.\n   *     If false, this next subsection is of the same section.\n   */\n  nextSubSectionMeasure(newSection) {\n    if (newSection) {\n      let section = this.getCurrentSection();\n      if (section.hasOwnProperty('subsections')) {\n        // First measure of the first subsection.\n        this.uiData.curSubSectionIndex = 0;\n        this.uiData.curSubSectionMeasure = 1;\n      } else {\n        this.uiData.curSubSectionIndex = -1;\n        this.uiData.curSubSectionMeasure = -1;\n      }\n    } else {\n      if (this.uiData.curSubSectionIndex != -1) {\n        this.uiData.curSubSectionMeasure += 1;\n        let currentSection = this.getCurrentSection();\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n            currentSection.hasOwnProperty('subsections'),\n            '[songchart.js] Current section (index: '\n            + this.uiData.curSectionIndex + ') does not have subsections, yet '\n            + 'incrementing to next subsection');\n        let currentSubSection =\n            currentSection.subsections[this.uiData.curSubSectionIndex];\n        // Measure count starts from 1.\n        if (this.uiData.curSubSectionMeasure > currentSubSection.sublength) {\n          // Next subsection.\n          this.uiData.curSubSectionIndex += 1;\n          _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"checkState\"](\n            this.uiData.curSubSectionIndex\n                < currentSection.subsections.length,\n            '[songchart.js] Incrementing to next subsection index out of '\n            + ' bound: ' + this.uiData.curSectionIndex + ', subsection index: '\n            + this.uiData.curSubSectionIndex);\n          this.uiData.curSubSectionMeasure = 1;\n        }\n      }\n    }\n  }\n\n  /** Update next section. Returns false if the end has been reached. */\n  nextSection() {\n    this.uiData.curSectionIndex += 1;\n    if (this.uiData.curSectionIndex >= this.json.sections.length) {\n      this.reset();\n      return false;\n    }\n    let section = this.getCurrentSection();\n    this.uiData.curSectionName = section.name;\n    this.uiData.curSectionLength = section.length;\n    this.nextSubSectionMeasure(/* newSection= */ true);\n    return true;\n  }\n\n  getUiData() {\n    return this.uiData;\n  }\n\n  appendSection() {\n    this.json.sections.push({\n        \"name\": \"Untitled\",\n        \"length\": 8,\n    });\n  }\n\n  toggle() {\n    this.uiData.enabled = !this.uiData.enabled;\n  }\n\n  /**\n   * Sum of sub sections lengths must match section's total length. \n   * @returns List of section indices that violate this condition, or an empty\n   *     list.\n   */\n  validateSubSectionsLength() {\n    let indices = [];\n    for (let i = 0; i < this.json.sections.length; i++) {\n      let section = this.json.sections[i];\n      let sum = 0;\n      if (!section.hasOwnProperty('subsections')) {\n        continue;\n      }\n      for (let j = 0; j < section.subsections.length; j++) {\n        sum += section.subsections[j].length;\n      }\n      if (sum != section.length) {\n        indices.push(i);\n      }\n    }\n    return indices;\n  }\n\n  // For testing only.\n  setCountInMeasures(measures) {\n    this.uiData.countIn.lengthMeasures = measures;\n  }\n\n  /**\n   * Fetches song chart from given url.\n   * @param {string} url Url.\n  async fetchFromJson(url) {\n    let response = await fetch(url);\n    let song = await response.json();\n\n    // wait 1 second\n    await new Promise((resolve, reject) => setTimeout(resolve, 1000));\n\n    return song;\n  }\n  */\n}\n\n\n\n//# sourceURL=webpack:///./src/js/songchart.js?");

/***/ }),

/***/ "./src/js/storage.js":
/*!***************************!*\
  !*** ./src/js/storage.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Storage; });\n/* Check if local storage is available.\n * From https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n */\nfunction storageAvailable(window, type) {\n  var storage;\n  try {\n    storage = window[type];\n    var x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  }\n  catch(e) {\n    return e instanceof DOMException && (\n      // everything except Firefox\n      e.code === 22 ||\n      // Firefox\n      e.code === 1014 ||\n      // test name field too, because code might not be present\n      // everything except Firefox\n      e.name === 'QuotaExceededError' ||\n      // Firefox\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n      // acknowledge QuotaExceededError only if there's something already stored\n      (storage && storage.length !== 0);\n  }\n}\n\nclass Storage {\n  constructor(window) {\n    this.storageAvailable = storageAvailable(window, 'localStorage');\n    this.window = window;\n  }\n\n  isStorageAvailable() {\n    return this.storageAvailable;\n  }\n\n  store(name, value) {\n    if (this.isStorageAvailable()) {\n      try {\n        this.window.localStorage.setItem(name, value);\n        return true;\n      } catch (e) {\n        console.warn('Failed to store ' + name + ' in storage: ' + e);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  get(name) {\n    if (this.isStorageAvailable()) {\n      // getItem() returns null if value is not stored.\n      let value = this.window.localStorage.getItem(name);\n      if (value) {\n        return value;\n      }\n    }\n    return '';\n  }\n}\n\n\n//# sourceURL=webpack:///./src/js/storage.js?");

/***/ }),

/***/ "./src/js/utils.js":
/*!*************************!*\
  !*** ./src/js/utils.js ***!
  \*************************/
/*! exports provided: checkState, checkIsDefined, sprintf, log, warn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkState\", function() { return checkState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkIsDefined\", function() { return checkIsDefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sprintf\", function() { return sprintf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warn\", function() { return warn; });\nvar sprintf = (str, ...argv) => !argv.length ? str : \n    sprintf(str = str.replace(sprintf.token||\"$\", argv.shift()), ...argv);\n    \nfunction checkState(cond, message, ...argv) {\n  if (!cond) {\n    console.error(\"[ERROR] INVALID STATE: \" + sprintf(message, ...argv));\n    return false;\n  }\n  return true;\n}\n\nfunction checkIsDefined(name, value) {\n  if (typeof value !== 'undefined') {\n    if (value !== null){\n      return true;\n    }\n  }\n  console.error(\"[ERROR] %s is not defined: %s\", name, value);\n  return false;\n}\n\nfunction log(message, ...argv) {\n  console.log(sprintf(message, ...argv));\n}\n\nfunction warn(message, ...argv) {\n  console.warn(sprintf(message, ...argv));\n}\n\n\n\n//# sourceURL=webpack:///./src/js/utils.js?");

/***/ }),

/***/ "./src/js/visualization.js":
/*!*********************************!*\
  !*** ./src/js/visualization.js ***!
  \*********************************/
/*! exports provided: Viz */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viz\", function() { return Viz; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n/* harmony import */ var _viz_squares_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viz_squares.js */ \"./src/js/viz_squares.js\");\n/* harmony import */ var _viz_circles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viz_circles.js */ \"./src/js/viz_circles.js\");\n\n\n\n\nconst SQUARES = 'squares';\nconst CIRCLES = 'circles';\nconst STYLES = [SQUARES, CIRCLES];\n\nclass Viz {\n  constructor(window, document, audio) {\n    this.audio = audio;\n    this.audioContext = audio.getAudioContext();\n    this.window = window;\n    this.document = document;\n\n    this.canvas;\n\n    this.animationLoopId = -1;\n\n    // The last 'box' we drew on the screen\n    this.lastNoteDrawn = {note: -1, time: 0};\n\n    // Notes that have been put into the web audio, and may or may not have\n    // played yet. {note, time}\n    this.notesInQueue = [];\n\n    this.uiData = {\n      style: CIRCLES,\n      styles: STYLES,\n    }\n  }\n\n  /** Appends note in the queue for visualization. */\n  appendNote(note, time) {\n    this.notesInQueue.push({note: note, time: time});\n  }\n\n  initCanvas() {\n    // TODO(#27): For some reason we still need this setTimeout() here, though\n    // the whole thing is already within a window.on('load', {}) listener.\n    this.window.setTimeout(() => {\n      console.log('initing canvas');\n\n      this.canvas = this.document.getElementById('viz');\n      this.resetCanvas();\n\n      this.setStyle(this.uiData.style);\n\n      this.window.onorientationchange = () => { this.resetCanvas(); };\n      this.window.onresize = () => { this.resetCanvas(); };\n\n      this.draw(onload=true);\n    }, 500);\n  }\n\n  /** Draws the visualization on screen.\n   * @param {bool} onload - If true, draw only once on page load.\n   */\n  draw(onload=false) {\n    // Compare note time with current audioContext time for exact timing.\n    let currentTime = this.audioContext.currentTime;\n    var currentNote = this.lastNoteDrawn;\n\n    while (this.notesInQueue.length &&\n           this.notesInQueue[0].time <= currentTime) {\n      currentNote = this.notesInQueue[0];\n      this.notesInQueue.splice(0, 1);  // remove note from queue\n    }\n\n    // We only need to draw if the note has moved.\n    if (onload || currentNote != this.lastNoteDrawn) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"log\"](\n          '[viz] currentTime: $, note: $, noteTime: $ ($)',\n          currentTime, currentNote.note, currentNote.time.toFixed(6),\n          (currentNote.time - currentTime).toFixed(6));\n      this.painter.draw(Math.floor(currentNote.note / 4));\n      this.lastNoteDrawn = currentNote;\n    }\n\n    // Set up to draw again\n    if (!onload) {\n      this.animationLoopId = this.window.requestAnimationFrame(() => { this.draw(); });\n    }\n  }\n\n  resetCanvas() {\n    let d = this.document.getElementById('viz-container');\n    // TODO(#27): Without setTimeout() method in resetCanvas(),\n    // clientWidth for some reason will be 0, though this whole thing is already\n    // within window.on('load', {}) event.\n    this.canvas.width = d.clientWidth;\n    this.canvas.height = d.clientHeight;\n    if (typeof this.painter !== 'undefined') {\n      this.painter.resetCanvas();\n    }\n  }\n\n  startDrawing() {\n    this.animationLoopId = this.window.requestAnimationFrame(() => { this.draw(); });\n  }\n\n  stopDrawing() {\n    if (this.animationLoopId != -1) {\n      this.window.cancelAnimationFrame(this.animationLoopId);\n      this.animationLoopId = -1;\n      this.lastNoteDrawn = {note: -1, time: 0};\n      this.draw(onload=true);\n    }\n  }\n\n  setStyle(style) {\n    this.uiData.style = style;\n    if (style === SQUARES) {\n      this.painter = new _viz_squares_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.canvas, {});\n    } else if (style === CIRCLES) {\n      this.painter = new _viz_circles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.canvas);\n    } else {\n      console.warn('Unexpected visualization style: ' + style);\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack:///./src/js/visualization.js?");

/***/ }),

/***/ "./src/js/viz_circles.js":
/*!*******************************!*\
  !*** ./src/js/viz_circles.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Circles; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\nclass Circles {\n  constructor(canvas, options={}) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.lineWidth = 2;\n    this.updateNumBeats(options.numBeats || 4);\n  }\n\n  /* noteNumber must be between 0 and numBeats - 1. */\n  draw(noteNumber) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (let i = 0; i < this.numBeats; i++) {\n      let p = this.positions[i];\n      this.ctx.beginPath();\n      if (i == noteNumber) {\n        this.ctx.fillStyle = this.getColor(i);\n        this.ctx.arc(\n          p.centerX,\n          p.centerY,\n          p.radius,\n          /* startAngle= */ 0,\n          /* endAngle= */ Math.PI * 2,  // radians\n          /* antiClockwise= */ false);\n        this.ctx.fill();\n      } else {\n        this.ctx.strokeStyle = this.getColor(i);\n        this.ctx.arc(\n          p.centerX,\n          p.centerY,\n          p.radius,\n          /* startAngle= */ 0,\n          /* endAngle= */ Math.PI * 2,  // radians\n          /* antiClockwise= */ false);\n        this.ctx.stroke();\n      }\n    }\n  }\n\n  /* Called when window is updated such as resized. */\n  resetCanvas() {\n    this.positions = this.calcSizeAndPosition();\n  }\n\n  calcSizeAndPosition() {\n    let positions = [];\n    let paddingRatio = 0.15;  // 15% of width for padding on each side.\n    let diameterRatio = 0.1;  // 10% of width.\n    let padding = this.canvas.width * 0.15;\n    let diameter = Math.min(this.canvas.width * diameterRatio, 0.8 * this.canvas.height);\n    let paddingY = (this.canvas.height - diameter) / 2;\n    let spacing = Math.floor((this.canvas.width - padding * 2 - diameter * 4) / (this.numBeats - 1));\n    let radius = diameter / 2;\n    for (let i = 0; i < this.numBeats; i++) {\n      positions.push({\n        centerX: Math.floor(padding + (diameter + spacing) * i + radius),\n        centerY: Math.floor(paddingY + radius),\n        radius: Math.floor(radius),\n      });\n    }\n    return positions;\n  }\n\n  getColor(noteNumber) {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"sprintf\"](\n        'rgb($, $, $)',\n        50, 150, Math.floor(255 - (255 / this.numBeats) * noteNumber));\n  }\n\n  /** Change how many beats per measure. */\n  updateNumBeats(beats) {\n    this.numBeats = beats;\n    this.positions = this.calcSizeAndPosition();\n  }\n}\n\n\n//# sourceURL=webpack:///./src/js/viz_circles.js?");

/***/ }),

/***/ "./src/js/viz_squares.js":
/*!*******************************!*\
  !*** ./src/js/viz_squares.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Squares; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n\n\nclass Squares {\n  constructor(canvas, options={}) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.lineWidth = 2;\n    this.updateNumBeats(options.numBeats || 4);\n  }\n\n  /* noteNumber must be between 0 and numBeats - 1. */\n  draw(noteNumber) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (let i = 0; i < this.numBeats; i++) {\n      let p = this.positions[i];\n      if (i == noteNumber) {\n        this.ctx.fillStyle = this.getColor(i);\n        this.ctx.fillRect(p.x, p.y, p.width, p.height);\n      } else {\n        this.ctx.strokeStyle = this.getColor(i);\n        this.ctx.strokeRect(p.x, p.y, p.width, p.height);\n      }\n    }\n  }\n\n  /* Called when window is updated such as resized. */\n  resetCanvas() {\n    this.positions = this.calcSizeAndPosition();\n  }\n\n  calcSizeAndPosition() {\n    let positions = [];\n    let paddingRatio = 0.15;  // 15% of width for padding on each side.\n    let boxSizeRatio = 0.1;  // 10% of width.\n    let padding = this.canvas.width * 0.15;\n    let boxSize = Math.min(this.canvas.width * boxSizeRatio, 0.8 * this.canvas.height);\n    let paddingY = (this.canvas.height - boxSize) / 2;\n    let spacing = Math.floor((this.canvas.width - padding * 2 - boxSize * 4) / (this.numBeats - 1));\n    for (let i = 0; i < this.numBeats; i++) {\n      positions.push({\n        x: Math.floor(padding + (boxSize + spacing) * i),\n        y: Math.floor(paddingY),\n        width: Math.floor(boxSize),\n        height: Math.floor(boxSize)\n      });\n    }\n    return positions;\n  }\n\n  getColor(noteNumber) {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"sprintf\"](\n        'rgb($, $, $)',\n        50, 150, Math.floor(255 - (255 / this.numBeats) * noteNumber));\n  }\n\n  /** Change how many beats per measure. */\n  updateNumBeats(beats) {\n    this.numBeats = beats;\n    this.positions = this.calcSizeAndPosition();\n  }\n}\n\n\n//# sourceURL=webpack:///./src/js/viz_squares.js?");

/***/ })

/******/ });